---
title: Part V - Cluster Themes with Reinert Textual Data Clustering
author: Rees Morrison
date: '2022-01-29'
slug: []
categories:
  - Analysis
tags: ["Reinert Textual Data Clustering"]
draft: yes
---

```{r packages, echo=F, warning=FALSE, message=FALSE, include=FALSE, results='hide'}

knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)

library(tidyverse)  
library(ggthemes) 
library(ggrepel) 
library(readxl) 
library(GGally)
library(tidytext) 

library(blogdown)
 
library(rainette)  # had problem installing faststack
library(cluster) # clustering algorithms and gap statistic
library(factoextra) # distance matrix and plot k-means clusters

library(kableExtra)

```


```{r means1, eval=TRUE, warning=FALSE, echo=FALSE}

comboData <- read_xlsx(path = "C:/Users/Rees Morrison/Documents/R/Projects/CLIENTS/Themes/Analytics/comboData.xlsx")

# convert Theme to factor - why?  to try to add labels to corr matrix
comboData$Theme <- as.factor(comboData$Theme)

comboDataMtx <- as.matrix(comboData)  # all numeric, row names 1 to 20

```

```{r normalize1}
comboScaled <- scale(x = comboData[ , 2:20], center = TRUE, scale = TRUE)

comboScaledDF <- as.data.frame(scale(x = comboData[ , 2:20]))
comboScaledDF$Metric <- comboData[  , 1]

```

Concluding this fifth post in my notes on centrality and complexity, the Reinert textual clustering method dates to Max Reinert's articles in 1983. After removing portions of blog posts that are similar to all posts, as well as blogdown header material, I combined all the posts for a Theme into a single "text."  Then I used R's rainette package to perform a Reinert textual clustering on those 24 texts.  Here are some characteristics of the method:

* it assigns each text (Theme) to only one cluster  
* it is better suited for small “homogeneous” documents
* it uses a *singular value decomposition* (SVD) of a *document-term matrix* (DTM) created from the corpus of all texts [more on those two methods in later posts]

The Reinert algorithm carries out $\text{\underline{divisive}}$ hierarchical clustering with the goal to maximise the inter-cluster $\text{\underline{Chi-squared distance}}$ between clustered texts.  The algorithm is applied to the DTM, which only stores the presence or absence of terms, not their frequencies. 

The algorithm splits the DTM into two clusters by maximizing the **Chi-squared distance** between them. It carries out the following steps:

* first, texts (Themes) are ordered according to their coordinates on the first axis of the **correspondence analysis** (CA) of the binary matrix (see[DisplayR](https://www.displayr.com/how-correspondence-analysis-works/) for a clear explanation of CA;
    
* next, Themes are grouped in two clusters based on this order, and the grouping with the maximum inter-cluster **Chi-squared distance** is kept;

* based on this grouping, each Theme is in turn assigned to the other cluster. If this new assignment gives a higher inter-cluster Chi-squared value, the Theme is kept in the other cluster. The operation is repeated until no new assignment gives a higher Chi-squared value;
    
* on the resulting clusters' binary matrices, features are selected based on their frequency and on a contingency coefficient minimum value; and
    
* the largest of the two resulting clusters is then split with the same algorithm.

```{r rainette, message=FALSE, echo=FALSE, warnings=FALSE}
# read tidytext file, postWords, created in Themes/BlogNLPWriting.Rmd, with results saved in Themes as .xlsx.  I created PostCombo and then did tidytext to break out all the words

postWords <- readxl::read_xlsx(path = "C:/Users/Rees Morrison/Documents/R/Projects/CLIENTS/Themes/postWords.xlsx")

rainDFM <- postWords %>% group_by(Theme, word) %>% summarise(count = n()) %>% 
  tidytext::cast_dfm(., document = Theme, term = word, value = count)

library(rainette)
# rainClus <- rainette(rainDFM, k = 5, min_segment_size = 5, doc_id = "Theme")
rainClus <- rainette::rainette(rainDFM, k = 18, doc_id = "Theme")

rainCut <- cutree_rainette(hres = rainClus, k = 9)

library(quanteda)
library(quanteda.textstats)
rainStats <- rainette_stats(groups = rainCut, dtm = rainDFM, measure = c("chi2"), n_terms = 10, show_negative = TRUE, max_p = 0.05)

rainDF <- data.frame(C1 = rainStats[[1]][1:2], C2 = rainStats[[2]][1:2], C3 = rainStats[[3]][1:2], C4 = rainStats[[4]][1:2], C5 = rainStats[[5]][1:2], C6 = rainStats[[6]][1:2], C7 = rainStats[[7]][1:2], C8 = rainStats[[8]][1:2], C9 = rainStats[[9]][1:2])

colnames(rainDF) <- str_remove_all(string = colnames(rainDF), pattern = "\\.feature")
colnames(rainDF) <- str_remove_all(string = colnames(rainDF), pattern = "\\.chi2")

rainette_plot(res = rainClus, dtm = rainDFM, k = 9, type = "bar", n_terms = 10, free_scales = TRUE, measure = "chi2", show_negative = "FALSE", text_size = 12)

# rainette2_plot(res = rainClus, dtm = rainDFM, k = 0, type = "bar", n_terms = 10, free_scales = TRUE, measure = "chi2", show_negative = "FALSE", text_size = 12)
```

### Combine the pairings from the three clustering methods

Once the closest-pair are produced from k-means clustering, agglomerative hierarchical clustering, and Reinert text clustering, I combined them into a dataframe so that we can find out whether any Theme is closest to any other Theme more than once (or even three times).\

```{r cluscombo, message=FALSE, echo=FALSE, warnings=FALSE}

##  COMBINE THE CLUSTER RESULTS OF CLOSEST THEMES FROM KMEANS, HIERARCH AND RAINETTE

ThemeLookup <- read_xlsx("C:/Users/Rees Morrison/Documents/R/Projects/CLIENTS/Themes/Metrics of Themes.xlsx", sheet = "NoSThemes", range = "B1:D25")

RainLookup <- data.frame(ClusterGroup = rainClus$group) %>% 
  mutate(Alpha = seq(1:length(ClusterGroup))) %>% 
  left_join(., ThemeLookup[  , c(1, 3)])

RainClosest <- RainLookup %>% group_by(ClusterGroup) %>% summarise(closeThemes = paste0(Theme, collapse = "&")) 

ClusCombo <- as.data.frame(str_split(string = RainClosest$closeThemes, pattern = "&", simplify = TRUE))
colnames(ClusCombo) <- c("Theme1", "Theme2", "Theme3", "Theme4")

ClusCombo$Method <- "Rainette"

HierDF <- readxl::read_xlsx(path = "C:/Users/Rees Morrison/Documents/R/Projects/CLIENTS/Themes/Analytics/HierDF.xlsx")

# set up for bind row the method's results to Rainette and k-means
HierClus <- HierDF[  , c("Theme.x", "Theme.y")]
HierClus <- as.data.frame(str_split(string = HierClus$Theme.y, pattern = "&", simplify = TRUE))
HierClus$Theme1 <- HierDF$Theme.x
HierClus$Method <- "Hierarchical"
colnames(HierClus) <- c("Theme2", "Theme3", "Theme4", "Theme5", "Theme1", "Method")
HierClus <- HierClus[  , c(5, 1:4, 6)]

# ClusCombo = Rainette ("nights"); MinDist = k-means ("night"); HierClus = hiearchical dendrogrm
ClusAllCombo <- bind_rows(ClusCombo, MinDist[  , c("Theme1", "Theme2", "Method")], HierClus)

#remove blank rows
ClusAllCombo <- ClusAllCombo %>% filter(nchar(Theme1) > 1) %>% arrange(Theme1, Theme2)
ClusAllCombo$Theme2Rev <- ClusAllCombo$Theme2
ClusAllCombo$Theme1Rev <- ClusAllCombo$Theme1
ClusAllCombo$MethodRev <- ClusAllCombo$Method
ClusAllRevd <- ClusAllCombo[   , c(1,2, 5, 7:9)] # rearrange to ressemble and drop 3:5s
colnames(ClusAllRevd) <- c("Theme1", "Theme2", "Method", "Theme1", "Theme2", "Method")

ClusAllRev2 <- data.frame(Theme1 = c(ClusAllRevd[   , 1], ClusAllRevd[   , 4]),
                          Theme2 = c(ClusAllRevd[   , 2], ClusAllRevd[   , 5]),
                          Method = c(ClusAllRevd[   , 3], ClusAllRevd[   , 6]))

ClusAllRev2 <- ClusAllRev2 %>% arrange(Theme1)

# do similar for Theme1s and Theme3s
ClusAllCombo$Theme31 <- ClusAllCombo$Theme1
ClusAllCombo$Theme33 <- ClusAllCombo$Theme3
ClusAllCombo$Method3 <- ClusAllCombo$Method

ClusAllThird <- ClusAllCombo %>% select(Theme31, Theme33, Method3)
ClusAllThird <- ClusAllThird[!(is.na(ClusAllThird$Theme33) | ClusAllThird$Theme33 == ""), ] # remove blanks  15 rows remain --- now , create the reverse of the Themes
ClusAllThird$Theme33Rev <- ClusAllThird$Theme33
ClusAllThird$Theme31Rev <- ClusAllThird$Theme31
ClusAllThird$MethodRev <- ClusAllThird$Method

ClusAll3rd <- data.frame(Theme1 = c(ClusAllThird[   , 1], ClusAllThird[   , 4]),
                         Theme2 = c(ClusAllThird[   , 2], ClusAllThird[   , 5]),
                         Method = c(ClusAllThird[   , 3], ClusAllThird[   , 6]))

colnames(ClusAll3rd) <- c("Theme1", "Theme2", "Method")
ClusAllRev2and3 <- bind_rows(ClusAllRev2, ClusAll3rd)
ClusAllRev2and3 <- ClusAllRev2and3 %>% arrange(Theme1, Theme2)


# do similar for Theme2s and Theme3s
ClusAllCombo$Theme23 <- ClusAllCombo$Theme2
ClusAllCombo$Theme323 <- ClusAllCombo$Theme3
ClusAllCombo$Method23 <- ClusAllCombo$Method

ClusAllThird2 <- ClusAllCombo %>% select(Theme23, Theme323, Method23)  #47 obs
ClusAllThird2 <- ClusAllThird2[!(is.na(ClusAllThird2$Theme323) | ClusAllThird2$Theme323 == ""), ] # no blanks  15 rows so, create the reverse of the Themes
ClusAllThird2$Theme23Rev <- ClusAllThird2$Theme323
ClusAllThird2$Theme323Rev <- ClusAllThird2$Theme23
ClusAllThird2$MethodRev <- ClusAllThird2$Method

ClusAll23rd <- data.frame(Theme1 = c(ClusAllThird2[   , 1], ClusAllThird2[   , 4]),
                         Theme2 = c(ClusAllThird2[   , 2], ClusAllThird2[   , 5]),
                         Method = c(ClusAllThird2[   , 3], ClusAllThird2[   , 6]))


colnames(ClusAll23rd) <- c("Theme1", "Theme2", "Method")
ClusAllRev1to3 <- bind_rows(ClusAllRev2, ClusAll3rd, ClusAll23rd)
ClusAllRev1to3 <- ClusAllRev1to3 %>% arrange(Theme1, Theme2)

# combine first three variables and keep uniques, because k-means has duplicates (two Themes are closest to each other), and hierarchical may have the same (two Themes merge with each other)

ClusAllRev1to3$concat <- paste(ClusAllRev1to3$Theme1, ClusAllRev1to3$Theme2, ClusAllRev1to3$Method)

ClusAllRev1to3.Uniq <- data.frame(Uniques = unique(ClusAllRev1to3$concat))

ClusAllRev1to3.Uniq$Uniques <- str_replace_all(string = ClusAllRev1to3.Uniq$Uniques, pattern = "sailing ships", replacement = "sailing")

ClusAllRev1to3.Uniq$Uniques <- str_replace_all(string = ClusAllRev1to3.Uniq$Uniques, pattern = "work  Rainette", replacement = "work work Rainette")

ClusAllRev1to3.Uniq$Uniques[1] <- "work work Rainette"

# write_xlsx(ClusAllRev1to3.Uniq, "C:/Users/Rees Morrison/Documents/R/Projects/CLIENTS/Themes/Analytics/ClusAllRev1to3Unique.xlsx")

Themes <- c("alcohol", "chance", "beauty", "silence", "work", "decisions", "destruction", "time", "death", "trains", "churches", "birds", "friends", "sailing", "sports", "wind", "soldiers", "clothes", "bridges", "dancing", "sleep", "rivers", "money", "night")

ClusAllSplit <- str_split(string = ClusAllRev1to3.Uniq$Uniques, pattern = " ", n = 3, simplify = TRUE)

ClusAllSplit <- as.data.frame(ClusAllSplit)  #124

# count of pairs per clustering method
ClusAllMethod <- ClusAllSplit %>% group_by(V3) %>% summarise(MethodCount = n())

ClusCount <- ClusAllSplit %>% group_by(V1, V2) %>% summarise(Freq = n()) %>% arrange(desc(Freq)) 

# write_xlsx(ClusCount, "C:/Users/Rees Morrison/Documents/R/Projects/CLIENTS/Themes/Analytics/ClusCount.xlsx")
# in the Excel file I cleaned it and created a table, to read in below

ClusTable <- read_xlsx(path = "C:/Users/Rees Morrison/Documents/R/Projects/CLIENTS/Themes/Analytics/ClusCount.xlsx")

ClusTable <- ClusTable[1:13, 10:14]
colnames(ClusTable) <- c("Theme", "Two", "One", "Theme", "One")

options(knitr.kable.NA = '') # remove NA in cells
kableExtra::kable(ClusTable, caption = 'Close Themes', align = "l",) %>% 
  kable_styling(latex_options = "HOLD_position")
```


```{r cluscombo2, message=FALSE, echo=FALSE, warnings=FALSE}
# create a data frame after table, drop zero frequencies
ClusDF <- data.frame(table(ClusAllSplit$V1, ClusAllSplit$V2)) %>% filter(Freq > 0)

# ThemeA ThemeB is same as ThemeB ThemeA, drop dupes
ClusDF$Var1 <- as.character(ClusDF$Var1)
Var1Order <- ClusDF %>% arrange(Var1)  # need to do Var2 separately, not vectorized, or they simply match perfectly

ClusDF$Var2 <- as.character(ClusDF$Var2)
Var2Order <- ClusDF %>% arrange(Var2)

Var1Order$TwoThemes <- str_c(Var1Order$Var1, Var1Order$Var2, sep = " ")
Var2Order$TwoThemesRev <- str_c(Var2Order$Var2, Var2Order$Var1, sep = " ")

ClusDFUnique <- data.frame(A = Var1Order$TwoThemes, B = Var2Order$TwoThemesRev)

ClusDFUnique <- cbind(Var1Order[ , 3:4], Var2Order[  , 3:4])

# ClusDFUnique <- rbind(Var1Order[ , 4], Var2Order[  , 4])

# RevPairs <- ClusDF$TwoThemesRev
# ClusDF$Pair <- ifelse(str_detect(string = ClusDF$TwoThemes, pattern = RevPairs), "Pair", "NoPair")

# ClusDFUnique <- cbind(ClusDF$TwoThemes, ClusDF$TwoThemesRev)
# ClusDFUnique <- dplyr::bind_rows(ClusDF$TwoThemes, ClusDF$TwoThemesRev)

# arrange both variables and test for identify of pairs
TwoThemesOrder <- sort(ClusDF$TwoThemes)
TwoThemesRevOrder <- sort(ClusDF$TwoThemesRev)

ClusDFUnique <- data.frame(A = TwoThemesOrder, B = TwoThemesRevOrder)

```

## Upcoming Post Series

Once the blog Themes from Art reaches 30 Themes (early February 2022), incorporates new metrics (e.g., newspaper references and Bing searches), drops the most dubious metrics (college majors and readability), and reconsiders the rank metrics (OED Bands and Top 1000 Words), the second series of five posts is likely to address:

*Part VI: Further Observations on Themes and Metrics

*Part VII: Cosine Similarity of Themes

*Part VIII: Latent Dirichelet Allocation (LDA)

*Part IX: Embeddings and Transformations

*Part X: Including Results of Above Algorithms into Theme Pairs Analysis

&nbsp;

Around April 2022, a third series of five posts may encompass 36 Themes, a further modified set of metrics, and the following topics:

*Part XI: Critique of Quantifying Centrality and Complexity

*Part XII: Principal Components Analysis (PCA)

*Part XIII: Latent Semantic Analysis (LSA) or Uniform Manifold Approximation of Proportion (UMAP)

*Part XIV: Correspondence Analysis (CA)

*Part XV: Further Extensions of Theme Pairs and Analysis

&nbsp;

A fourth series of posts, in the early Summer of 2022, may incorporate as many as 40 Themes.  Among its potential topics, we envision:

*Part XVI: More Clustering Techniques

*Part XVII: Metaclustering, Validation tests, Assumptions of the Models

*Part XVIII: Structural Topic Models (STM)

*Part XIX: Other Tools for Analyzing Relationships between Themes

*Part XX: Applications of Theme-Pair Findings to Centrality and Complexity

